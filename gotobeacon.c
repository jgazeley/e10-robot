#pragma config(Sensor, in1,    analog1,        sensorAnalog)
#pragma config(Sensor, dgtl1,  frontLimit,     sensorDigitalIn)
#pragma config(Sensor, dgtl2,  redLED,         sensorLEDtoVCC)
#pragma config(Sensor, dgtl3,  greenLED,       sensorLEDtoVCC)
#pragma config(Sensor, dgtl4,  yellowLED,      sensorLEDtoVCC)
#pragma config(Sensor, dgtl6,  armLowBumper,   sensorDigitalIn)
#pragma config(Sensor, dgtl7,  armHiBumper,    sensorDigitalIn)
#pragma config(Sensor, dgtl10, digital10,      sensorDigitalOut)
#pragma config(Sensor, dgtl11, digital11,      sensorDigitalOut)
#pragma config(Sensor, dgtl12, digital12,      sensorDigitalOut)
#pragma config(Motor,  port2,           rightMotor,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           armMotor,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// GROUP 4: robot states
#define FIND_RED							1			// find the red beacon
#define TURN_OFF_RED						2			// press the button on the red beacon
#define FIND_GREEN							3			// find the green beacon
#define CAPTURE_GREEN						4			// capture the green beacon
#define EXIT_ARENA 							5			// exit the arena
#define DONE								6			// mission accomplished

// GROUP 4: beacon frequencies
#define ONE_KILOHERTZ						0			// 0 = 1kHz (red)
#define TEN_KILOHERTZ						1			// 1 = 10kHz (green)

// GROUP 4: motor speeds
#define FULL_SPEED							127
#define HALF_SPEED							64
#define HALF_SPEED_REVERSE					(-64)
#define ZERO_SPEED							0

// GROUP 4: robot actions
#define TURN_LEFT 							0
#define TURN_RIGHT 							1
#define ARM_LOWER 							0
#define ARM_RAISE 							1

// GROUP 4: piezo buzzer
#define NOTE_A5   880
#define NOTE_GS5  831
#define NOTE_DS6  1245
#define NOTE_E6   1319
#define NOTE_FS6  1480
#define NOTE_G6   1568
#define NOTE_GS6  1661
#define NOTE_C7   2093

#define REST      0
#define END      -1   // end the song

int secret[] = {
  NOTE_G6, 16,  NOTE_FS6, 16,  NOTE_DS6, 16,  NOTE_A5, 16,
  NOTE_GS5, 16, NOTE_E6,  16,  NOTE_GS6, 16,  NOTE_C7, 16,
  END
};

int tempo = 120;  // BPM


// GROUP 4: prototypes
void robot_init();
void led_init(int cycles, int step_ms);
void set_target_freq(int freq);
int find_beacon(int targetFreq, int currentState, int nextState);
int turn_off_red_beacon();
void stop_drive();
void reverse_drive();
void move_arm(int direction);
void turn_robot(int direction, int turnTime);
void play_song(int song[], int bpm);


// GIVEN prototypes
int  Expose_and_read(void);
void ReadPD(void);
void Find_max(void);
int  limit_pwm(int temp);
void Move(void);

// Global Variables
int state, ambient_level, slow_level, stop_level, expose_time, steer_sensitivity, forward_speed, slow_speed, spin_speed;

// initialize PD values for the global uses - will be modified at the appropriate timing in ReadPD function.
int PD0, PD1, PD2, PD3, PD4, PD5, PD6, PD7, PD_sum;
// initialize max values
int max_val, max_no = 0;

//#################################################################################//
//############################*!! GROUP 4 Main Program !!*#########################//
//#################################################################################//

task main() {
    robot_init();
    led_init(10, 500);
    state = FIND_RED;

    while (true) {
        switch (state) {

            /*====================================================================
              STATE 1: FIND_RED  (find the [1kHz] red beacon)
            ====================================================================*/
            case FIND_RED: {
                // When the red beacon is found, find_beacon() should set state to TURN_OFF_RED.
            	turnLEDOn(redLED); find_beacon(ONE_KILOHERTZ, FIND_RED, TURN_OFF_RED);
            } break;
            //============================== END STATE 1 =========================


            /*====================================================================
              STATE 2: TURN_OFF_RED  (turn off red beacon, back away)
            ====================================================================*/
            case TURN_OFF_RED: {
            	if (turn_off_red_beacon()) { turnLEDOff(redLED); state = FIND_GREEN; }
            } break;
            //============================== END STATE 2 =========================


            /*====================================================================
              STATE 3: FIND_GREEN  (seek the [10 kHz] green beacon)
            ====================================================================*/
            case FIND_GREEN: {
                // When the green beacon is found, find_beacon() should set state to CAPTURE_GREEN.
            	turnLEDOn(greenLED); find_beacon(TEN_KILOHERTZ, FIND_GREEN, CAPTURE_GREEN);
            } break;
            //============================== END STATE 3 =========================


            /*====================================================================
              STATE 4: CAPTURE_GREEN  (capture the green beacon)
            ====================================================================*/
            case CAPTURE_GREEN: {
                move_arm(ARM_LOWER);
                delay(1000);

                // Next state:
                turnLEDOff(greenLED);
                state = EXIT_ARENA;
            } break;
            //============================== END STATE 4 =========================


            /*====================================================================
              STATE 5: EXIT_ARENA  (leave the arena)
            ====================================================================*/
            case EXIT_ARENA: {
                // TODO: exit strategy:
            	delay(2000);
                move_arm(ARM_RAISE);

                // Next state:
                state = DONE;
            } break;
            //============================== END STATE 5 =========================


            /*====================================================================
              STATE 6: DONE (idle)
            ====================================================================*/
            case DONE: {
                // NOP
            } break;
            //============================== END STATE 6 =========================

            default: {
                // default to a known state.
                state = FIND_RED;
            } break;
        }
    }
}

//##############################*!! GROUP 4 Helpers !!*############################//
//#################################################################################//

void robot_init() {
	ambient_level = 200; // used in 'move'
	slow_level = 5000;// used in move
	stop_level = 6000;//used in move
	expose_time = 5; // expose time was changed from 3ms to 5ms (3ms in easyC -> 5ms in RobotC)
	steer_sensitivity = 20;//used in move
	forward_speed = 35;//forward speed , used in move
	slow_speed = 25;//slow speed , used in move
	spin_speed = 30;//spin speed (for searching mode),used in move
}

void led_init(int cycles, int step_ms) {
    // start with all off
    turnLEDOff(redLED); turnLEDOff(greenLED); turnLEDOff(yellowLED);

    for (int i = 0; i < cycles; i++) {
        // red -> green -> yellow
        turnLEDOn(redLED);    turnLEDOff(greenLED); turnLEDOff(yellowLED); delay(step_ms);
        turnLEDOff(redLED);   turnLEDOn(greenLED);  turnLEDOff(yellowLED); delay(step_ms);
        turnLEDOff(redLED);   turnLEDOff(greenLED); turnLEDOn(yellowLED);  delay(step_ms);
    }

    // end with all off
    turnLEDOff(redLED); turnLEDOff(greenLED); turnLEDOff(yellowLED);
}

// set the beacon frequency
void set_target_freq(int freq) {        // 0 = 1kHz (red), 1 = 10kHz (green)
	SensorValue[digital10] = freq;
}

// find beacon sequence (same for red and green beacon)
int find_beacon(int targetFreq, int currentState, int nextState) {
set_target_freq(targetFreq);

while (state == currentState) {
	ReadPD();
	Find_max();
	Move();

	// front limit switch pressed -> reached beacon
	if (!SensorValue[frontLimit]) {
		stop_drive();
		state = nextState;   // advance the state machine
		delay(1000);
		return 1;            // beacon found
	}
}

return 0; // loop exited without finding the beacon
}

int turn_off_red_beacon() {
	move_arm(ARM_LOWER);
	delay(1000);
	move_arm(ARM_RAISE);
	delay(1000);

	// ReadPD();
	// if (/*PD_sum is low*/) {        // <-------- need a real condition here
		play_song(secret, tempo);

		// Reverse for 2 seconds, then stop.
		reverse_drive();
		delay(2000);
		stop_drive();
		return 1;
	// }
	// else
	// 	return 0;
}

// stop drive motors
void stop_drive() {
	motor[rightMotor]  = ZERO_SPEED;
	motor[leftMotor] = ZERO_SPEED;
}

// reverse drive motors, half speed
void reverse_drive() {
	motor[rightMotor]  = HALF_SPEED_REVERSE;
	motor[leftMotor] = HALF_SPEED_REVERSE;
}

// move the arm up or down
void move_arm(int direction, int duration) {
	if (direction == ARM_LOWER) {
		motor[armMotor] = HALF_SPEED;
//		while(SensorValue[armLowBumper]) {}        // motor spins until arm contacts the top of the beacon
	}
	else if (direction == ARM_RAISE) {
		motor[armMotor] = HALF_SPEED_REVERSE; 			// reverse to raise arm
//		while(SensorValue[armHiBumper]) {}         // motor spins until arm contacts the top of the beacon
	}
	delay(duration);
	motor[armMotor] = ZERO_SPEED;
}

// turn robot left or right for a specific duration
void turn_robot(int direction, int turnTime) {
	if (direction == TURN_LEFT) {
		motor[rightMotor]  = HALF_SPEED;
		motor[leftMotor]   = HALF_SPEED_REVERSE;
	}
	else if (direction == TURN_RIGHT) {
		motor[rightMotor]  = HALF_SPEED_REVERSE;
		motor[leftMotor]   = HALF_SPEED;
	}
	delay(turnTime);
	stop_drive();
}

// Convert and play an Arduino-style song on VEX using PlayTone()
void play_song(int song[], int bpm)
{
  // whole note duration in milliseconds (matches your Arduino math)
  // wholeNoteMs = 240000 / tempo;
  int wholeNoteMs = 240000 / bpm;

  int i = 0;
  while (true)
  {
    int pitch   = song[i];
    if (pitch == END) break;   // done

    int divider = song[i + 1];
    int noteMs;

    // Handle dotted notes (negative divider) like your Arduino code:
    // dotted = base + (base/2) = 1.5 * (whole/base)
    if (divider < 0) {
      int base = -divider;
      noteMs = (wholeNoteMs / base) + (wholeNoteMs / (2 * base));
    } else {
      noteMs = wholeNoteMs / divider;
    }

    // RobotC duration units are 1/100 sec (10 ms).
    // We'll keep ~90% ON-time like your tone(..., 0.9*duration):
    int noteTicks   = noteMs / 10;             // total note length in ticks
    if (noteTicks < 1) noteTicks = 1;          // ensure minimum tick
    int soundTicks  = (noteTicks * 9) / 10;    // 90% ON

    if (pitch == REST) {
      // Rest: just wait the full note length
      wait1Msec(noteTicks * 10);
    } else {
      // Play the tone, then wait the full note length
      PlayTone(pitch, soundTicks);
      wait1Msec(noteTicks * 10);
    }

    i += 2; // advance to next (pitch, divider) pair
  }
}

//##############################*!! GIVEN Helpers !!*##############################//
//#################################################################################//

/*The accumulator accumulates(or integrates) the rectified signal over a period of time (set by the expose and read)
The accumulated voltage read by SensorValue[analog1](an analog voltage) is read by the controller.
The expose_time period essentially set the ?gain? or ?sensitivity? of the overall circuit.*/
int Expose_and_read(){
	SensorValue[digital11] = 1; // close the shutter, clear the film, and increment the counter
	delay(5); // Wait for 5ms for things to settle
	SensorValue[digital11] = 0; // open shutter for exposure
	delay(expose_time); // expose time = 3ms to 8ms (can be adjusted)
	int intensity = SensorValue[analog1]; // get the IR intensity reading
	return intensity; // return the analog input 1
}

/*Read_PD calculates PD_sum which is the sum of all 8 photo diodes?outputs.
PD_sum is a measure of the distance between the robot and the beacon. The sensing
sensitivity is set by expose_time*/

void ReadPD(){
	SensorValue[digital11] = 1; // close the shutter, clear the film, and increment the counter
	SensorValue[digital12] = 1; // initialize counter value to '0'
	SensorValue[digital12] = 0; // allow counter to count
	delay(5); // 5ms wait for things settling down
	SensorValue[digital11] = 0; // open shutter and expose film
	delay(expose_time); // expose time = 3ms to 8ms (can be adjusted)
	PD0 = SensorValue[analog1];
	PD1 = Expose_and_read();
	PD2 = Expose_and_read();
	PD3 = Expose_and_read();
	PD4 = Expose_and_read();
	PD5 = Expose_and_read();
	PD6 = Expose_and_read();
	PD7 = Expose_and_read();
	PD_sum = PD0 + PD1 + PD2 + PD3 + PD4 + PD5 + PD6 + PD7;
}

/*This function compares the magnitude of the variables PD0~PD7 and stores the maximum value
in max_val and the number of the photo diode that has the maximum value in max_no.*/

void Find_max(){
	max_val = PD0; // default = PD0;
	max_no = 0;

	if(PD1 > max_val){
		max_val = PD1;
		max_no = 1;
	}
	if(PD2 > max_val){
		max_val = PD2;
		max_no = 2;
	}
	if(PD3 > max_val){
		max_val = PD3;
		max_no = 3;
	}
	if(PD4 > max_val){
		max_val = PD4;
		max_no = 4;
	}
	if(PD5 > max_val){
		max_val = PD5;
		max_no = 5;
	}
	if(PD6 > max_val){
		max_val = PD6;
		max_no = 6;
	}
	if(PD7 > max_val){
		max_val = PD7;
		max_no = 7;
	}
}

/*
Limits results of move function to max speed	and output to the motors*/
int limit_pwm(int temp){
	int limited = 0;

	if(temp > 127){
		limited = 127;
		} else if (temp < -127){
		limited = -127;
		} else{
		limited = temp;
	}

	return limited;

}

/*Move function helps to check if beacon is found or otherwise it will be search mode	 looking for the beacon.
This function also calculates the speed, steering sensitivity and the heading direction so the robot moves to beacon*/

void Move(){
	int tempSpeed = 0;
	int error = 4 - max_no;//heading direction error , if PD4==max_no, then no error
	int steer = error * steer_sensitivity;//steering effort is proportioinal to heading error
	int speed = forward_speed;//forward speed (normal speed)

	if(PD_sum < ambient_level){ // looking for the beacon if background noise is
		speed = 0;//serach mode=>no forward motion
		steer = -spin_speed;//search mode =>spin
	}
	if(PD_sum > slow_level){//Beacon is near!
		speed = slow_speed;//slow down
	}
	// deleted the stop statement when the beacon is found, because we'll	 use the limit switch to stop the motors	which is more reliable.


	tempSpeed = limit_pwm(steer + speed);
	motor[port2] = tempSpeed; // right, port 1
	tempSpeed = limit_pwm(steer - speed);
	motor[port10] = tempSpeed; // left, port	 10
}

