#pragma config(Sensor, in1,    analog1,        sensorAnalog)
#pragma config(Sensor, dgtl1,  frontLimit,     sensorDigitalIn)
#pragma config(Sensor, dgtl2,  leftForkBumper, sensorDigitalIn)
#pragma config(Sensor, dgtl3,  rightForkBumper, sensorDigitalIn)
#pragma config(Sensor, dgtl7,  armHiBumper,    sensorDigitalIn)
#pragma config(Sensor, dgtl10, digital10,      sensorDigitalOut)
#pragma config(Sensor, dgtl11, digital11,      sensorDigitalOut)
#pragma config(Sensor, dgtl12, digital12,      sensorDigitalOut)
#pragma config(Motor,  port2,           rightMotor,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           armMotor,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// GROUP 4: robot states
#define FIND_RED								1			// find the red beacon
#define TURN_OFF_RED						2			// press the button on the red beacon
#define FIND_GREEN							3			// find the green beacon
#define CAPTURE_GREEN						4			// capture the green beacon
#define EXIT_ARENA 							5			// exit the arena
#define DONE										6			// mission accomplished

// GROUP 4: beacon frequencies
#define ONE_KILOHERTZ						0			// 0 = 1kHz (red)
#define TEN_KILOHERTZ						1			// 1 = 10kHz (green)

// GROUP 4: motor speeds
#define FULL_SPEED							127
#define FULL_SPEED_REVERSE                  (-127)
#define HALF_SPEED							64
#define HALF_SPEED_REVERSE					(-64)
#define ZERO_SPEED							0

// GROUP 4: robot actions
#define ARM_LOWER 							0
#define ARM_RAISE 							1

// --- TF-Luna via Nano (UART1) ---
int LUNA_CM = -1;
int  luna_read_cm(int timeout_ms);
int  median3_cm(void);

// GROUP 4: prototypes
void robot_init();
void set_target_freq(int freq);
int find_beacon(int targetFreq, int currentState, int nextState);
int turn_off_red_beacon();
void forward_drive(int speed);
void reverse_drive();
void stop_drive();
void move_arm(int direction, int duration);

void clearUART(TUARTs port) {
    while (getChar(port) != -1) {
        // keep reading and discarding
    }
}

int isDigit(char c) {
    return (c >= '0' && c <= '9');
}

void uart_init(void) {
  setBaudRate(uartOne, baudRate9600);
}

void vex_cmd(char c) { sendChar(uartOne, c); wait1Msec(2); }

int luna_read_cm(int timeout_ms) {
    char buffer[10];
    int charCount = 0;
    int receivedValue = -1; // Default to -1 (error)

    // Clear any old, stale data from the UART buffer
    // This is CRITICAL to get the *latest* reading
    clearUART(uartOne);

    clearTimer(T3);
    while (time1[T3] < timeout_ms)
    {
        int inChar = getChar(uartOne);
        if (inChar == -1) continue; // No char yet

        if (inChar == '\n') { // End of number
            if (charCount > 0) {
                buffer[charCount] = '\0';
                receivedValue = atoi(buffer);
            }
            break; // Got our number
        }
        if (inChar == '\r') continue; // Ignore carriage return

        // Add the character to our buffer if it's a digit
        if (isDigit(inChar) || inChar == '-') {
            if (charCount < 9) { // Prevent buffer overflow
                buffer[charCount] = (char)inChar;
                charCount++;
            }
        }
    }
    return receivedValue;
}

int median3_cm(void) {
    int v[3];
    v[0] = luna_read_cm(100); // 100ms timeout
    v[1] = luna_read_cm(100);
    v[2] = luna_read_cm(100);

    // Filter out bad reads
    int a[3], n = 0;
    if (v[0] > 0) a[n++] = v[0];
    if (v[1] > 0) a[n++] = v[1];
    if (v[2] > 0) a[n++] = v[2];

    if (n == 0) return -1; // All reads failed

    // insertion sort tiny array
    for (int i = 1; i < n; i++) {
      int k = a[i], j = i - 1;
      while (j >= 0 && a[j] > k) { a[j+1] = a[j]; j--; }
      a[j+1] = k;
    }
    return a[n/2]; // Return the median of valid reads
}


// GIVEN prototypes
int  Expose_and_read(void);
void ReadPD(void);
void Find_max(void);
int  limit_pwm(int temp);
void Move(void);


// Global Variables
int state, ambient_level, slow_level, stop_level, expose_time, steer_sensitivity, forward_speed, slow_speed, spin_speed;

// initialize PD values for the global uses - will be modified at the appropriate timing in ReadPD function.
int PD0, PD1, PD2, PD3, PD4, PD5, PD6, PD7, PD_sum;
// initialize max values
int max_val, max_no = 0;

//#################################################################################//
//############################*!! GROUP 4 Main Program !!*#########################//
//#################################################################################//

task main() {
    robot_init();
    uart_init();
    wait1Msec(1000);          // 1 second to wait for Nano to boot up
    vex_cmd('I');   // LED init chase on the Nano
    state = FIND_RED;

    while (true) {
        switch (state) {

            /*====================================================================
              STATE 1: FIND_RED  (find the [1kHz] red beacon)
            ====================================================================*/
            case FIND_RED: {
                // When the red beacon is found, find_beacon() should set state to TURN_OFF_RED.
				vex_cmd('R');   // Red LED on Nano
            	find_beacon(ONE_KILOHERTZ, FIND_RED, TURN_OFF_RED);
            }
            break;
            //============================== END STATE 1 =========================


            /*====================================================================
              STATE 2: TURN_OFF_RED  (turn off red beacon, back away)
            ====================================================================*/
            case TURN_OFF_RED: {
            	if (turn_off_red_beacon()) {
              	vex_cmd('O');   // Red LED off
            	state = FIND_GREEN;
            	}
            }
            break;
            //============================== END STATE 2 =========================


            /*====================================================================
              STATE 3: FIND_GREEN  (seek the [10 kHz] green beacon)
            ====================================================================*/
            case FIND_GREEN: {
                // When the green beacon is found, find_beacon() should set state to CAPTURE_GREEN.
				vex_cmd('G');   // Green LED on Nano
            	find_beacon(TEN_KILOHERTZ, FIND_GREEN, CAPTURE_GREEN);
            }
            break;
            //============================== END STATE 3 =========================


            /*====================================================================
              STATE 4: CAPTURE_GREEN  (capture the green beacon)
            ====================================================================*/
            case CAPTURE_GREEN: {
                move_arm(ARM_LOWER, 500);
                delay(1000);

                // Next state:
              	vex_cmd('O');   // Green LED off
                state = EXIT_ARENA;
            }
            break;
            //============================== END STATE 4 =========================


            /*====================================================================
              STATE 5: EXIT_ARENA  (Continuous Seek + Overturn + Fallback + Bumper)
            =====================================================================*/
            case EXIT_ARENA: {
                vex_cmd('Y');   // Yellow LED on Nano
                // Make sure UART1 is at 9600
                setBaudRate(uartOne, baudRate9600);

                // ---- TUNING ----
                const int EXIT_DIST_CM  = 400;  // "ideal" exit distance, 12 ft ~ 365 cm
                const int STOP_NEAR_CM  = 25;   // Safety stop distance
                const int DRIVE_PWM_FWD = 127;  // Forward drive speed
                const int SPIN_PWM_SLOW = 64;   // Smooth spin speed
                const int BACK_UP_MS    = 750;  // How long to back up
                const int OVERTURN_MS   = 250;   // How long to turn past the edge

                // ---- FALLBACK CONSTANTS ----
                const int SPIN_TIMEOUT_MS       = 6500; // Time for one 360 spin
                const int FALLBACK_TOLERANCE_CM = 20;   // +/- 20 cm for fallback match

                // Internal states for this logic
                #define SEEK_STATE_SPIN           0 // Seeking ideal exit
                #define SEEK_STATE_OVERTURN       1 // Overturing past the edge
                #define SEEK_STATE_DRIVE          2 // Driving forward
                #define SEEK_STATE_FALLBACK_SPIN  3 // Seeking max_seen_cm again

                static int  exit_seek_state;
                static bool is_first_run = true;
                static int  seek_max_seen_cm; // Tracks the best distance

                // Initialize the sub-state on the first run
                if (is_first_run) {
                    exit_seek_state  = SEEK_STATE_SPIN;
                    is_first_run     = false;
                    seek_max_seen_cm = -1; // Reset max distance
                    clearTimer(T1);        // T1 is the spin timeout timer
                    // writeDebugStreamLine("--- EXIT ARENA: Continuous Seek ---");
                }

                int attempts = 0;
                const int MAX_ATTEMPTS = 1000; // Safety breakout

                clearTimer(T2); // Main drive timer

                while (state == EXIT_ARENA && attempts < MAX_ATTEMPTS)
                {
                    attempts++;

                    // --- Always update the sensor ---
                    LUNA_CM = median3_cm(); // Update debugger

                    switch(exit_seek_state)
                    {
                        //-------------------------------------------------
                        case SEEK_STATE_SPIN:
                            // --- STATE 1: SPINNING FOR *IDEAL* EXIT ---
                            motor[rightMotor] =  SPIN_PWM_SLOW;
                            motor[leftMotor]  =  SPIN_PWM_SLOW;

                            // Track the max distance seen so far
                            if (LUNA_CM > seek_max_seen_cm) {
                                seek_max_seen_cm = LUNA_CM;
                            }

                            // 1. GOOD PATH: Did we find the ideal exit?
                            if (LUNA_CM > EXIT_DIST_CM)
                            {
                                // writeDebugStreamLine("Found IDEAL exit (d=%dcm). Overturing.", LUNA_CM);
                                clearTimer(T4); // Start overturn timer
                                exit_seek_state = SEEK_STATE_OVERTURN;
                                break;
                            }

                            // 2. TIMEOUT: Did we spin 360 and fail?
                            if (time1[T1] > SPIN_TIMEOUT_MS)
                            {
                                // writeDebugStreamLine("IDEAL scan failed. Max was %dcm.", seek_max_seen_cm);

                                // Check if the max we saw is even valid (not a wall)
                                if (seek_max_seen_cm > (STOP_NEAR_CM + FALLBACK_TOLERANCE_CM)) {
                                    // writeDebugStreamLine("Now seeking for fallback: >= %dcm", seek_max_seen_cm - FALLBACK_TOLERANCE_CM);
                                    exit_seek_state = SEEK_STATE_FALLBACK_SPIN;
                                    clearTimer(T1); // Reset timer for another 360
                                } else {
                                    // writeDebugStreamLine("Fallback failed, max was a wall. Retrying.");
                                    clearTimer(T1); // Reset timer, stay in this state
                                    seek_max_seen_cm = -1;
                                }
                            }
                            break;

                        //-------------------------------------------------
                        case SEEK_STATE_FALLBACK_SPIN:
                            // --- STATE 3: SPINNING FOR *FALLBACK* EXIT ---
                            motor[rightMotor] =  SPIN_PWM_SLOW;
                            motor[leftMotor]  =  SPIN_PWM_SLOW;

                            // 1. FOUND FALLBACK:
                            // Check if current reading is close to our recorded max
                            if (LUNA_CM >= (seek_max_seen_cm - FALLBACK_TOLERANCE_CM))
                            {
                                // writeDebugStreamLine("Found FALLBACK (d=%dcm). Overturing.", LUNA_CM);
                                clearTimer(T4); // Start overturn timer
                                exit_seek_state = SEEK_STATE_OVERTURN;
                            }

                            // 2. TOTAL FAILURE:
                            if (time1[T1] > SPIN_TIMEOUT_MS) // Spun another 360
                            {
                                // writeDebugStreamLine("Total failure, couldn't find max again. Stopping.");
                                state = DONE; // Give up
                            }
                            break;

                        //-------------------------------------------------
                        case SEEK_STATE_OVERTURN:
                            // --- STATE 2: CONTINUING SPIN TO CENTER ---
                            motor[rightMotor] =  -SPIN_PWM_SLOW;
                            motor[leftMotor]  =  -SPIN_PWM_SLOW;

                            if (time1[T4] > OVERTURN_MS)
                            {
                                // writeDebugStreamLine("Overturn complete. Driving.");
                                stop_drive();
                                exit_seek_state = SEEK_STATE_DRIVE;
                                clearTimer(T2); // Reset main drive timer
                            }
                            break;

                        //-------------------------------------------------
                        case SEEK_STATE_DRIVE:
                            // --- STATE 3: DRIVING FORWARD ---
                            forward_drive(DRIVE_PWM_FWD);

            // Active-low: 0 = pressed (like frontLimit)
            if (!SensorValue[rightForkBumper]) {
                // Hit something with the right fork -> too close to right wall
                stop_drive();

                // Back up a bit
                reverse_drive();
                wait1Msec(BACK_UP_MS / 2);   // smaller backup than a full "oh no" event
                stop_drive();

                // Nudge left: small pivot away from the right wall
                motor[rightMotor] =  -SPIN_PWM_SLOW;   // same as you already had
                motor[leftMotor]  =  -SPIN_PWM_SLOW;
                wait1Msec(500);                        // tweak this duration as needed
                stop_drive();

                // Debounce
                wait1Msec(100);
                break;  // stay in SEEK_STATE_DRIVE
            }
            else if (!SensorValue[leftForkBumper]) {
                // Hit something with the left fork -> too close to left wall
                stop_drive();

                // Back up a bit
                reverse_drive();
                wait1Msec(BACK_UP_MS / 2);
                stop_drive();

                // Nudge right: pivot opposite way of the right bumper
                motor[rightMotor] =  SPIN_PWM_SLOW;
                motor[leftMotor]  =  SPIN_PWM_SLOW;
                wait1Msec(500);                        // tweak as needed
                stop_drive();

                // Debounce
                wait1Msec(100);
                break;  // stay in SEEK_STATE_DRIVE
            }
                            // -------- END NEW BUMPER LOGIC -----------

                            // Check for a wall *ahead* via LiDAR while driving
                            if (LUNA_CM > 0 && LUNA_CM < STOP_NEAR_CM)
                            {
                                // writeDebugStreamLine("! OBSTACLE %dcm, backing up.", LUNA_CM);
                                stop_drive();

                                reverse_drive();
                                wait1Msec(BACK_UP_MS);
                                stop_drive();

                                // Reset *everything* and start over scanning
                                is_first_run = true;
                            }

                            // If we drive for 6.5 seconds with no problems, assume we're out.
                            if (time1[T2] > 6500)
                            {
                                // writeDebugStreamLine("Drive timer complete.");
                                state = DONE; // Exit mission
                            }
                            break;
                    } // end switch

                    wait1Msec(20); // Poll loop delay (keeps tasks happy)

                } // end while

                stop_drive();
                move_arm(ARM_RAISE, 0);
                is_first_run = true; // Reset for next time
                state = DONE; // Finish
            } break;

			//============================== END STATE 5 =========================


            /*====================================================================
              STATE 6: DONE (idle)
            ====================================================================*/
							case DONE: {
								vex_cmd('F');   // Start flashing pattern on Nano
				        if (!SensorValue[frontLimit]) {
				        	vex_cmd('I');
				          delay(750);
									state = FIND_RED;   // reset the state machine
								}
		          }
	            break;
            //============================== END STATE 6 =========================

            default: {
                // default to a known state.
                state = FIND_RED;
            }
            break;
        }
    }
}

//##############################*!! GROUP 4 Helpers !!*############################//
//#################################################################################//

void robot_init() {
	ambient_level = 200; // used in 'move'
	slow_level = 5000;// used in move
	stop_level = 6000;//used in move
	expose_time = 5; // expose time was changed from 3ms to 5ms (3ms in easyC -> 5ms in RobotC)
	steer_sensitivity = 20;//used in move
	forward_speed = 35;//forward speed , used in move
	slow_speed = 30;//slow speed , used in move
	spin_speed = 30;//spin speed (for searching mode),used in move
}

// set the beacon frequency
void set_target_freq(int freq) {        // 0 = 1kHz (red), 1 = 10kHz (green)
	SensorValue[digital10] = freq;
}

// find beacon sequence (same for red and green beacon)
int find_beacon(int targetFreq, int currentState, int nextState) {
	set_target_freq(targetFreq);


	while (state == currentState) {
	    // *** NEW: spam the state marker ***
	    if (targetFreq == ONE_KILOHERTZ) {
	        vex_cmd('R');   // FIND_RED
	    } else {
	        vex_cmd('G');   // FIND_GREEN
	    }
	    // *******************************

	    ReadPD();
	    Find_max();
	    Move();

		// front limit switch pressed -> reached beacon
		if (!SensorValue[frontLimit]) {
			stop_drive();
			state = nextState;   // advance the state machine
			delay(1000);
			return 1;            // beacon found
		}
	}

	return 0; // loop exited without finding the beacon
}

int turn_off_red_beacon() {
  while (true) {
	move_arm(ARM_LOWER, 500);
	delay(500);

    // Raise until the high limit switch is hit
	move_arm(ARM_RAISE, 0);
    delay(750);

    // Check if beacon looks OFF yet
    ReadPD();                  // updates PD_sum
    if (PD_sum < 1000) {
      // Back away once and finish
	  vex_cmd('S');  // secret tune
      delay(1000);
      reverse_drive();
      delay(500);
      stop_drive();
      return 1;
    }
    // Otherwise loop and try the sequence again
  }
}

// reverse drive motors, half speed
void forward_drive(int speed) {
	motor[rightMotor]  = 88;
	motor[leftMotor] = -127;
}

// reverse drive motors, half speed
void reverse_drive() {
	motor[rightMotor]  = -64;
	motor[leftMotor] = 64;
}

// stop drive motors
void stop_drive() {
	motor[rightMotor]  = 0;
	motor[leftMotor] = 0;
}

// move the arm up or down
void move_arm(int direction, int duration) {
	if (direction == ARM_LOWER) {
		motor[armMotor] = FULL_SPEED;
		delay(duration);
		motor[armMotor] = ZERO_SPEED;
	}
	else if (direction == ARM_RAISE) {
		motor[armMotor] = FULL_SPEED_REVERSE;
		while (SensorValue[armHiBumper]) { /* wait */ }
		motor[armMotor] = ZERO_SPEED;
	}
}


//##############################*!! GIVEN Helpers !!*##############################//
//#################################################################################//

/*The accumulator accumulates(or integrates) the rectified signal over a period of time (set by the expose and read)
The accumulated voltage read by SensorValue[analog1](an analog voltage) is read by the controller.
The expose_time period essentially set the ?gain? or ?sensitivity? of the overall circuit.*/
int Expose_and_read(){
	SensorValue[digital11] = 1; // close the shutter, clear the film, and increment the counter
	delay(5); // Wait for 5ms for things to settle
	SensorValue[digital11] = 0; // open shutter for exposure
	delay(expose_time); // expose time = 3ms to 8ms (can be adjusted)
	int intensity = SensorValue[analog1]; // get the IR intensity reading
	return intensity; // return the analog input 1
}

/*Read_PD calculates PD_sum which is the sum of all 8 photo diodes?outputs.
PD_sum is a measure of the distance between the robot and the beacon. The sensing
sensitivity is set by expose_time*/

void ReadPD(){
	SensorValue[digital11] = 1; // close the shutter, clear the film, and increment the counter
	SensorValue[digital12] = 1; // initialize counter value to '0'
	SensorValue[digital12] = 0; // allow counter to count
	delay(5); // 5ms wait for things settling down
	SensorValue[digital11] = 0; // open shutter and expose film
	delay(expose_time); // expose time = 3ms to 8ms (can be adjusted)
	PD0 = SensorValue[analog1];
	PD1 = Expose_and_read();
	PD2 = Expose_and_read();
	PD3 = Expose_and_read();
	PD4 = Expose_and_read();
	PD5 = Expose_and_read();
	PD6 = Expose_and_read();
	PD7 = Expose_and_read();
	PD_sum = PD0 + PD1 + PD2 + PD3 + PD4 + PD5 + PD6 + PD7;
}

/*This function compares the magnitude of the variables PD0~PD7 and stores the maximum value
in max_val and the number of the photo diode that has the maximum value in max_no.*/

void Find_max(){
	max_val = PD0; // default = PD0;
	max_no = 0;

	if(PD1 > max_val){
		max_val = PD1;
		max_no = 1;
	}
	if(PD2 > max_val){
		max_val = PD2;
		max_no = 2;
	}
	if(PD3 > max_val){
		max_val = PD3;
		max_no = 3;
	}
	if(PD4 > max_val){
		max_val = PD4;
		max_no = 4;
	}
	if(PD5 > max_val){
		max_val = PD5;
		max_no = 5;
	}
	if(PD6 > max_val){
		max_val = PD6;
		max_no = 6;
	}
	if(PD7 > max_val){
		max_val = PD7;
		max_no = 7;
	}
}

/*
Limits results of move function to max speed	and output to the motors*/
int limit_pwm(int temp){
	int limited = 0;

	if(temp > 127){
		limited = 127;
		} else if (temp < -127){
		limited = -127;
		} else{
		limited = temp;
	}

	return limited;

}

/*Move function helps to check if beacon is found or otherwise it will be search mode	 looking for the beacon.
This function also calculates the speed, steering sensitivity and the heading direction so the robot moves to beacon*/

void Move(){
	int tempSpeed = 0;
	int error = 4 - max_no;//heading direction error , if PD4==max_no, then no error
	int steer = error * steer_sensitivity;//steering effort is proportioinal to heading error
	int speed = forward_speed;//forward speed (normal speed)

	if(PD_sum < ambient_level){ // looking for the beacon if background noise is
		speed = 0;//serach mode=>no forward motion
		steer = -spin_speed;//search mode =>spin
	}
	if(PD_sum > slow_level){//Beacon is near!
		speed = slow_speed;//slow down
	}
	// deleted the stop statement when the beacon is found, because we'll	 use the limit switch to stop the motors	which is more reliable.


	tempSpeed = limit_pwm(steer + speed);
	motor[port2] = tempSpeed; // right, port 1
	tempSpeed = limit_pwm(steer - speed);
	motor[port10] = tempSpeed; // left, port	 10
}
