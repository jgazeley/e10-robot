#pragma config(Sensor, in1,		 analog1,			sensorAnalog)
#pragma config(Sensor, dgtl10, digital10,			sensorDigitalOut)
#pragma config(Sensor, dgtl11, digital11,			sensorDigitalOut)
#pragma config(Sensor, dgtl12, digital12,			sensorDigitalOut)
#pragma config(Sensor, dgtl4, frontLimit,			sensorTouch)  // limit switch to detect front contact
#pragma config(Sensor, dgtl6, armLowBumper,			sensorTouch)  // bumper switch to detect arm contact with beacon
#pragma config(Sensor, dgtl7, armHiBumper,			sensorTouch)  // bumper switch to detect arm is fully raised
#pragma config(Motor, port3,						armMotor,		 tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor, port2,						rightMotor,		 tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor, port10,						leftMotor,		 tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard							 !!*//

// GROUP 4: robot states
#define FIND_RED								1			// find the red beacon
#define TURN_OFF_RED						2			// press the button on the red beacon
#define FIND_GREEN							3			// find the green beacon
#define CAPTURE_GREEN						4			// capture the green beacon
#define EXIT_ARENA 							5			// exit the arena
#define DONE										6			// mission accomplished

// GROUP 4: beacon frequencies
#define ONE_KILOHERTZ						0			// 0 = 1kHz (red)
#define TEN_KILOHERTZ						1			// 1 = 10kHz (green)

// GROUP 4: motor speeds
#define FULL_SPEED							127
#define HALF_SPEED							64
#define HALF_SPEED_REVERSE			(-64)
#define ZERO_SPEED							0

// GROUP 4: robot actions
#define TURN_LEFT 							0
#define TURN_RIGHT 							1
#define ARM_LOWER 							0
#define ARM_RAISE 							1

// GROUP 4: prototypes
void robot_init();
void setBeaconFreq(int freq);
int findBeacon(int targetFreq, int currentState, int nextState);
void stopDrive();
void reverseDrive();
void moveArm(int direction);
// void turnRobot(int direction, int turnTime);
// void celebration();

// GIVEN prototypes
int  Expose_and_read(void);
void ReadPD(void);
void Find_max(void);
int  limit_pwm(int temp);
void Move(void);

// Global Variables
int state, ambient_level, slow_level, stop_level, expose_time, steer_sensitivity, forward_speed, slow_speed, spin_speed;

// initialize PD values for the global uses - will be modified at the appropriate timing in ReadPD function.
int PD0, PD1, PD2, PD3, PD4, PD5, PD6, PD7, PD_sum;
// initialize max values
int max_val, max_no = 0;

//############################*!! GROUP 4 Main Program !!*#########################//
//#################################################################################//
task main(){
	robot_init();

	// find the red beacon (1kHz)
	findBeacon(ONE_KILOHERTZ, FIND_RED, TURN_OFF_RED);

	// turn off red beacon and then back away
	while(state == TURN_OFF_RED) {
		// turn off red beacon (activate arm motor, wait til arm makes contact)
		moveArm(ARM_LOWER);
		delay(1000);			// pause for 1 second before raising arm
		moveArm(ARM_RAISE);
		ReadPD();

//		if (/*PD_sum is low*/) {	// <-------- TODO: need a real condition here

			// back away from red beacon
			reverseDrive();
			delay(2000);		// reverse for 2 seconds
			stopDrive();

			state = FIND_GREEN;
//		}
	}

	// find the green beacon (10kHz)
	findBeacon(TEN_KILOHERTZ, FIND_GREEN, CAPTURE_GREEN);

	// capture green beacon
	while(state == CAPTURE_GREEN) {

		// grab green beacon (activate arm motor, wait til arm makes contact)
		moveArm(ARM_LOWER);
		state = EXIT_ARENA;
	}

	// exit the arena
	while(state == EXIT_ARENA) {

		// TODO: leave the arena

		// release green beacon once we know we have left the arena
		moveArm(ARM_RAISE);
		// celebration();
		state = DONE;
	}
}


//##############################*!! GROUP 4 Helpers !!*############################//
//#################################################################################//

void robot_init() {
	ambient_level = 200; // used in 'move'
	slow_level = 5000;// used in move
	stop_level = 6000;//used in move
	expose_time = 5; // expose time was changed from 3ms to 5ms (3ms in easyC -> 5ms in RobotC)
	steer_sensitivity = 20;//used in move
	forward_speed = 35;//forward speed , used in move
	slow_speed = 25;//slow speed , used in move
	spin_speed = 30;//spin speed (for searching mode),used in move
	state = FIND_RED;
}

// set the beacon frequency
void setBeaconFreq(int freq) {        // 0 = 1kHz (red), 1 = 10kHz (green)
  SensorValue[digital10] = freq;
}

// find beacon sequence (same for red and green beacon)
int findBeacon(int targetFreq, int currentState, int nextState) {
  setBeaconFreq(targetFreq);

  while (state == currentState) {
    ReadPD();
    Find_max();
    Move();

    if (SensorValue[frontLimit]) {
      stopDrive();
      state = nextState;
      return 1;
    }
  }
  return 0;
}

// stop drive motors
void stopDrive() {
  motor[rightMotor]  = ZERO_SPEED;
  motor[leftMotor] = ZERO_SPEED;
}

// reverse drive motors, half speed
void reverseDrive() {
  motor[rightMotor]  = HALF_SPEED_REVERSE;
  motor[leftMotor] = HALF_SPEED_REVERSE;
}

// move the arm up or down
void moveArm(int direction) {
	if (direction == ARM_LOWER) {
	  motor[armMotor] = HALF_SPEED;
	  while(!SensorValue[armLowBumper]) {}        // motor spins until arm contacts the top of the beacon
	  motor[armMotor] = ZERO_SPEED;
	}
	else if (direction == ARM_RAISE) {
	  motor[armMotor] = HALF_SPEED_REVERSE; 			// reverse to raise arm
	  while(!SensorValue[armHiBumper]) {}         // motor spins until arm contacts the top of the beacon
	  motor[armMotor] = ZERO_SPEED;
	}
}

// // turn robot left or right for a specific duration
// void turnRobot(int direction, int turnTime) {
// 	if (direction == TURN_LEFT) {
//   	motor[rightMotor]  = HALF_SPEED;
//   	motor[leftMotor]   = HALF_SPEED_REVERSE;
// 	}
// 	else if (direction == TURN_RIGHT) {
//   	motor[rightMotor]  = HALF_SPEED_REVERSE;
//   	motor[leftMotor]   = HALF_SPEED;
// 	}
//   delay(turnTime);
//   stopDrive();
// }

// void celebration() {
// 		turnRobot(TURN_LEFT, 4000);
// 		moveArm(ARM_LOWER);
// 		moveArm(ARM_RAISE);
// 		turnRobot(TURN_RIGHT, 4000);
// 		moveArm(ARM_LOWER);
// 		moveArm(ARM_RAISE);
// 		turnRobot(TURN_LEFT, 4000);
// 		turnRobot(TURN_RIGHT, 1000);
// 		// activate piezo buzzer to play the secret tune
// }

//##############################*!! GIVEN Helpers !!*##############################//
//#################################################################################//

/*The accumulator accumulates(or integrates) the rectified signal over a period of time (set by the expose and read)
The accumulated voltage read by SensorValue[analog1](an analog voltage) is read by the controller.
The expose_time period essentially set the ?gain? or ?sensitivity? of the overall circuit.*/
int Expose_and_read(){
	SensorValue[digital11] = 1; // close the shutter, clear the film, and increment the counter
	delay(5); // Wait for 5ms for things to settle
	SensorValue[digital11] = 0; // open shutter for exposure
	delay(expose_time); // expose time = 3ms to 8ms (can be adjusted)
	int intensity = SensorValue[analog1]; // get the IR intensity reading
	return intensity; // return the analog input 1
}

/*Read_PD calculates PD_sum which is the sum of all 8 photo diodes?outputs.
PD_sum is a measure of the distance between the robot and the beacon. The sensing
sensitivity is set by expose_time*/

void ReadPD(){
	SensorValue[digital11] = 1; // close the shutter, clear the film, and increment the counter
	SensorValue[digital12] = 1; // initialize counter value to '0'
	SensorValue[digital12] = 0; // allow counter to count
	delay(5); // 5ms wait for things settling down
	SensorValue[digital11] = 0; // open shutter and expose film
	delay(expose_time); // expose time = 3ms to 8ms (can be adjusted)
	PD0 = SensorValue[analog1];
	PD1 = Expose_and_read();
	PD2 = Expose_and_read();
	PD3 = Expose_and_read();
	PD4 = Expose_and_read();
	PD5 = Expose_and_read();
	PD6 = Expose_and_read();
	PD7 = Expose_and_read();
	PD_sum = PD0 + PD1 + PD2 + PD3 + PD4 + PD5 + PD6 + PD7;
}

/*This function compares the magnitude of the variables PD0~PD7 and stores the maximum value
in max_val and the number of the photo diode that has the maximum value in max_no.*/

void Find_max(){
	max_val = PD0; // default = PD0;
	max_no = 0;

	if(PD1 > max_val){
		max_val = PD1;
		max_no = 1;
	}
	if(PD2 > max_val){
		max_val = PD2;
		max_no = 2;
	}
	if(PD3 > max_val){
		max_val = PD3;
		max_no = 3;
	}
	if(PD4 > max_val){
		max_val = PD4;
		max_no = 4;
	}
	if(PD5 > max_val){
		max_val = PD5;
		max_no = 5;
	}
	if(PD6 > max_val){
		max_val = PD6;
		max_no = 6;
	}
	if(PD7 > max_val){
		max_val = PD7;
		max_no = 7;
	}
}

/*
Limits results of move function to max speed	and output to the motors*/
int limit_pwm(int temp){
	int limited = 0;

	if(temp > 127){
		limited = 127;
	} else if (temp < -127){
		limited = -127;
	} else{
		limited = temp;
	}

	return limited;

}

/*Move function helps to check if beacon is found or otherwise it will be search mode	 looking for the beacon.
This function also calculates the speed, steering sensitivity and the heading direction so the robot moves to beacon*/

void Move(){
	int tempSpeed = 0;
	int error = 4 - max_no;//heading direction error , if PD4==max_no, then no error
	int steer = error * steer_sensitivity;//steering effort is proportioinal to heading error
	int speed = forward_speed;//forward speed (normal speed)

	if(PD_sum < ambient_level){ // looking for the beacon if background noise is
		speed = 0;//serach mode=>no forward motion
		steer = -spin_speed;//search mode =>spin
	}
	if(PD_sum > slow_level){//Beacon is near!
		speed = slow_speed;//slow down
	}
	// deleted the stop statement when the beacon is found, because we'll	 use the limit switch to stop the motors	which is more reliable.


	tempSpeed = limit_pwm(steer + speed);
	motor[port2] = tempSpeed; // right, port 1
	tempSpeed = limit_pwm(steer - speed);
	motor[port10] = tempSpeed; // left, port	 10
}
